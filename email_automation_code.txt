
--- START OF /home/rick110/RickDrive/email_automation/frontend/app/api/auth/[...nextauth]/route.ts ---

// /home/rick110/RickDrive/email_automation/frontend/app/api/auth/[...nextauth]/route.ts

import NextAuth from "next-auth";
import GoogleProvider from "next-auth/providers/google";

// Helper function to refresh the Google access token
async function refreshAccessToken(token: any) {
  try {
    const url =
      "https://oauth2.googleapis.com/token?" +
      new URLSearchParams({
        client_id: process.env.GOOGLE_CLIENT_ID!,
        client_secret: process.env.GOOGLE_CLIENT_SECRET!,
        grant_type: "refresh_token",
        refresh_token: token.refreshToken,
      });

    const response = await fetch(url, {
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
      },
      method: "POST",
    });

    const refreshedTokens = await response.json();

    if (!response.ok) {
      throw refreshedTokens;
    }

    return {
      ...token,
      accessToken: refreshedTokens.access_token,
      accessTokenExpires: Date.now() + refreshedTokens.expires_in * 1000, // in milliseconds
      refreshToken: refreshedTokens.refresh_token ?? token.refreshToken, // Fall back to old refresh token
    };
  } catch (error) {
    console.error("Error refreshing access token", error);
    return { ...token, error: "RefreshAccessTokenError" };
  }
}

const handler = NextAuth({
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
      authorization: {
        params: {
          // Request access to Gmail API scopes. Add more as needed.
          scope: 'https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile https://www.googleapis.com/auth/gmail.readonly https://www.googleapis.com/auth/gmail.send',
          access_type: "offline", // This is crucial for getting a refresh token
          prompt: "consent", // This ensures the user is prompted for consent, which helps in getting a refresh token initially
        },
      },
    }),
  ],
  callbacks: {
    async jwt({ token, user, account }) {
      // Initial sign in
      if (account && user) {
        return {
          accessToken: account.access_token,
          refreshToken: account.refresh_token,
          accessTokenExpires: account.expires_at ? account.expires_at * 1000 : undefined, // Convert to milliseconds
          user,
        };
      }

      // Return previous token if the access token has not expired yet
      if (token.accessTokenExpires && Date.now() < token.accessTokenExpires) {
        return token;
      }

      // Access token has expired, try to update it
      return refreshAccessToken(token);
    },
    async session({ session, token }) {
      // Send properties to the client, such as an access_token from a provider.
      session.accessToken = token.accessToken;
      session.refreshToken = token.refreshToken; // Also expose refreshToken if you need it on the client
      session.user = token.user; // Expose the user object
      session.error = token.error; // Propagate any refresh errors
      return session;
    },
  },
  // You might want to add debug: true for development to see more logs
  debug: process.env.NODE_ENV === 'development',
});

export { handler as GET, handler as POST };
--- END OF /home/rick110/RickDrive/email_automation/frontend/app/api/auth/[...nextauth]/route.ts ---


--- START OF /home/rick110/RickDrive/email_automation/frontend/app/emails/page.tsx ---

"use client";
import { useSession } from "next-auth/react";
import { useEffect, useState, useCallback } from "react";
import { useRouter } from "next/navigation";
import Link from "next/link";

// Updated Email Interface for this list page
// Removed sentiment and suggested_reply_body as they are not used/provided here
interface Email {
  id: string;
  from: string;
  subject: string;
  snippet: string;
  reply_status: string;
  // full_body is not displayed on this list page, so it's optional but good to acknowledge
  full_body?: string;
}

export default function EmailPage() {
  const { data: session, status } = useSession();
  const [emails, setEmails] = useState<Email[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();

  const fetchEmails = useCallback(async (fetchNew: boolean = false) => {
    // Only proceed if session is authenticated
    if (status === "loading" || !session?.accessToken || !session.user?.email) {
      // Don't set error immediately, let useEffect handle redirection
      if (status === "unauthenticated") {
        router.push('/api/auth/signin');
      }
      return;
    }

    setLoading(true);
    setError(null);
    
    try {
      const res = await fetch(
        `http://localhost:8000/api/read-emails?fetch_new=${fetchNew}&limit=20`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            access_token: session.accessToken,
            // refresh_token is not needed for this specific endpoint on the backend
            user_email: session.user.email,
          }),
        }
      );

      if (!res.ok) {
        const errData = await res.json();
        // Handle authentication errors specifically
        if (res.status === 401) {
          setError("Session expired. Please sign in again.");
          router.push('/api/auth/signin'); // Redirect to sign-in on auth failure
          return;
        }
        throw new Error(errData.detail || `HTTP error! Status: ${res.status}`);
      }

      const data = await res.json();
      // Ensure data.emails is an array before setting state
      setEmails(Array.isArray(data.emails) ? data.emails : []);
    } catch (err: any) {
      setError(`Failed to fetch emails: ${err.message}`);
    } finally {
      setLoading(false);
    }
  }, [session, status, router]); // Added status and router to dependencies for useCallback

  useEffect(() => {
    if (status === "unauthenticated") {
      router.push('/api/auth/signin');
    } else if (status === "authenticated") {
      fetchEmails(false); // Fetch initially without 'fetch_new'
    }
  }, [status, router, fetchEmails]); // Ensure useEffect dependencies are complete

  return (
    <div className="p-6 font-sans">
      <h1 className="text-3xl font-bold mb-6">üì® Email Dashboard</h1>

      <section>
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-2xl font-semibold">Inbox</h2>
          <button
            onClick={() => fetchEmails(true)}
            className="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 disabled:opacity-50"
            disabled={loading} // Disable if loading
          >
            {loading ? "Refreshing..." : "Refresh Emails"}
          </button>
        </div>

        {error && <p className="text-red-600 mb-4 font-medium">Error: {error}</p>}
        
        {!loading && emails.length === 0 && (
          <p className="text-gray-500">No emails found in your inbox, or you haven't granted permissions.</p>
        )}

        <ul className="space-y-3">
          {emails.map((email) => (
            // Using Link component for client-side navigation
            <Link key={email.id} href={`/emails/${email.id}`} passHref>
              <li className="block p-4 border rounded-lg bg-white hover:bg-gray-50 cursor-pointer transition-colors duration-200">
                <p className="font-semibold text-gray-800">{email.from}</p>
                <p className="font-medium text-gray-900">{email.subject}</p>
                <p className="text-sm text-gray-600 mt-1 truncate">
                  {email.snippet}
                </p>
                <p className="text-xs text-blue-600 mt-2">
                  Status: <span className="font-medium">{email.reply_status}</span>
                </p>
              </li>
            </Link>
          ))}
        </ul>
      </section>
    </div>
  );
}
--- END OF /home/rick110/RickDrive/email_automation/frontend/app/emails/page.tsx ---


--- START OF /home/rick110/RickDrive/email_automation/frontend/app/emails/[id]/page.tsx ---

// /home/rick110/RickDrive/email_automation/frontend/app/emails/[id]/page.tsx
"use client";

import { useSession } from "next-auth/react";
import { useEffect, useState, useCallback } from "react";
import { useParams, useRouter } from "next/navigation";
import Link from "next/link";

interface Email {
  id: string;
  from: string;
  subject: string;
  snippet: string;
  reply_status: string;
  full_body: string; // Ensure this is always present after fetching
}

export default function EmailDetailPage() {
  const { data: session, status: sessionStatus } = useSession();
  const [email, setEmail] = useState<Email | null>(null);
  const [loading, setLoading] = useState(true); // Tracks initial email fetch loading
  const [error, setError] = useState<string | null>(null);
  const [sendStatus, setSendStatus] = useState<string | null>(null);
  const [replyBody, setReplyBody] = useState("");
  const [replySubject, setReplySubject] = useState("");

  // New states for AI generation
  const [aiPrompt, setAiPrompt] = useState(""); // User's input for AI generation context
  const [aiGenerating, setAiGenerating] = useState(false); // Tracks AI generation loading
  const [aiGenerationError, setAiGenerationError] = useState<string | null>(null); // Tracks AI specific errors

  const router = useRouter();
  const params = useParams();
  const id = params.id as string;

  // Fetches the details for a single email
  const fetchEmailDetails = useCallback(async () => {
    if (sessionStatus === "loading" || !session?.accessToken || !id) return;

    setLoading(true); // Start loading for email details
    setError(null);
    setSendStatus(null); // Clear previous send status
    setAiGenerationError(null); // Clear previous AI generation errors

    try {
      const res = await fetch(`http://localhost:8000/api/read-emails?email_id=${id}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          access_token: session.accessToken,
          user_email: session.user?.email,
        }),
      });

      if (!res.ok) {
        const errData = await res.json();
        if (res.status === 401) {
          router.push('/api/auth/signin');
          return;
        }
        throw new Error(errData.detail || `HTTP error! Status: ${res.status}`);
      }

      const data = await res.json();
      if (data.email) {
        setEmail(data.email);
        setReplySubject(`Re: ${data.email.subject || "No Subject"}`);
        setReplyBody(""); // Clear reply body for new email view
        setAiPrompt(""); // Clear AI prompt on new email load
      } else {
        throw new Error("Email data not found in the server response.");
      }

    } catch (err: any) {
      setError(`Failed to load email details: ${err.message}`);
    } finally {
      setLoading(false); // Ensure main loading state is ended after fetching email details
    }
  }, [id, session, sessionStatus, router]);

  useEffect(() => {
    if (sessionStatus === "unauthenticated") {
      router.push('/api/auth/signin');
    } else if (sessionStatus === "authenticated") {
      fetchEmailDetails();
    }
  }, [sessionStatus, router, fetchEmailDetails]);


  // Handles sending the reply
  const handleSendReply = async () => {
    if (!email || !session?.accessToken || !replyBody.trim() || !replySubject.trim()) {
        setSendStatus("Error: Missing information to send reply.");
        return;
    }

    setSendStatus("Sending...");
    try {
        const res = await fetch("http://localhost:8000/api/send-manual-email", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                access_token: session.accessToken,
                to: email.from,
                subject: replySubject,
                body: replyBody,
                original_message_id: email.id,
            }),
        });

        const data = await res.json();
        if (!res.ok) {
            if (res.status === 401) {
              setSendStatus("‚ùå Error: Session expired. Please sign in again.");
              router.push('/api/auth/signin');
              return;
            }
            throw new Error(data.detail || `Failed to send email with status: ${res.status}`);
        }

        setSendStatus("‚úÖ Reply sent successfully!");
        setReplyBody("");
        setReplySubject("");
        setTimeout(() => {
          router.push("/emails");
        }, 1500);

    } catch (err: any) {
        setSendStatus(`‚ùå Error sending reply: ${err.message}`);
    }
};

// NEW FUNCTION: Call Backend to Generate Reply with Groq
const handleGenerateWithAI = async () => {
    if (!email || !session?.accessToken || !session.user?.email || !aiPrompt.trim()) {
        setAiGenerationError("Please provide a prompt for AI generation.");
        return;
    }

    setAiGenerating(true); // Start Groq generation loading
    setAiGenerationError(null); // Clear previous AI generation errors
    setReplyBody("Generating AI reply..."); // Give immediate feedback in the textarea

    try {
        // Correct endpoint: /api/generate-email-body
        const res = await fetch("http://localhost:8000/api/generate-email-body", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                access_token: session.accessToken, // For backend auth
                user_email: session.user.email,
                context: aiPrompt, // User's prompt for AI context
                sender: email.from, // Original sender's email
                subject: email.subject, // Original email subject
            }),
        });

        const data = await res.json();
        if (!res.ok || !data.success) {
            if (res.status === 401) {
              setAiGenerationError("‚ùå Session expired. Please sign in again.");
              router.push('/api/auth/signin');
              return;
            }
            throw new Error(data.detail || 'Failed to generate email body.');
        }

        // Set the generated body to the replyBody state
        setReplyBody(data.generated_body);
        setAiPrompt(""); // Clear the AI prompt after generation
        setAiGenerationError(null); // Clear any previous AI errors
    } catch (err: any) {
        setAiGenerationError(`‚ùå AI Generation Error: ${err.message}`);
        // Optionally, clear the "Generating AI reply..." message if an error occurred
        if (replyBody === "Generating AI reply...") {
            setReplyBody("");
        }
    } finally {
        setAiGenerating(false); // End Groq generation loading
    }
};


  // Adjust overall loading state to consider both email fetching and AI generation
  if (loading) return <p className="p-6 text-gray-500">Loading email details...</p>;
  if (error) return <p className="p-6 text-red-600 font-medium">Error: {error}</p>;
  if (!email) return <p className="p-6 text-gray-500">No email data found.</p>;

  return (
    <div className="p-6 font-sans max-w-4xl mx-auto">
        <div className="flex justify-between items-center mb-6">
            <h1 className="text-3xl font-bold">Email Details</h1>
            <Link href="/emails">
                <span className="text-blue-500 hover:underline cursor-pointer">&larr; Back to Inbox</span>
            </Link>
        </div>

      {/* Email Information Section */}
      <section className="mb-8 p-4 border rounded-lg bg-white shadow-sm">
        <h2 className="text-xl font-semibold mb-4 border-b pb-2">Original Message</h2>
        <div className="space-y-2">
            <p><strong className="font-medium text-gray-700">From:</strong> {email.from}</p>
            <p><strong className="font-medium text-gray-700">Subject:</strong> {email.subject}</p>
            <div className="mt-2 text-gray-800 bg-gray-50 p-3 rounded-md min-h-[100px] overflow-auto">
                <p dangerouslySetInnerHTML={{ __html: email.full_body }}></p>
            </div>
            {email.snippet && email.full_body !== email.snippet && (
              <p className="mt-2 text-gray-600 text-sm italic">Snippet: {email.snippet}</p>
            )}
        </div>
      </section>

      {/* AI Generate Reply Section */}
      <section className="mb-8 p-4 border rounded-lg bg-white shadow-sm">
        <h2 className="text-xl font-semibold mb-3">‚ú® Generate Reply with AI</h2>
        <div className="space-y-4">
            <div>
                <label htmlFor="aiPrompt" className="block text-sm font-medium text-gray-700">
                    What should the AI's reply be about? (e.g., "accept the invitation", "decline politely and suggest another date", "ask for more details about the project")
                </label>
                <textarea
                    id="aiPrompt"
                    value={aiPrompt}
                    onChange={(e) => setAiPrompt(e.target.value)}
                    className="w-full p-3 border rounded-md focus:ring-purple-500 focus:border-purple-500 min-h-[80px]"
                    placeholder="E.g., Accept the meeting invitation."
                    disabled={aiGenerating}
                />
            </div>
            <button
                onClick={handleGenerateWithAI}
                className="bg-purple-600 text-white px-5 py-2 rounded-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 disabled:opacity-60 disabled:cursor-not-allowed"
                disabled={!aiPrompt.trim() || aiGenerating || !email}
            >
                {aiGenerating ? "Generating..." : "Generate AI Reply"}
            </button>
            {aiGenerationError && (
              <p className="text-red-600 text-sm font-medium mt-2">{aiGenerationError}</p>
            )}
        </div>
      </section>


      {/* Manual Reply Section */}
      <section className="p-4 border rounded-lg bg-white shadow-sm">
            <h2 className="text-xl font-semibold mb-3">‚úâÔ∏è Compose Reply</h2>
            <p className="text-sm text-gray-500 mb-4">
               Review the generated reply or type your own.
            </p>

            <div className="space-y-4">
                <div>
                  <label htmlFor="replyTo" className="block text-sm font-medium text-gray-700">To:</label>
                  <input
                    id="replyTo"
                    type="text"
                    value={email.from}
                    readOnly
                    className="w-full p-2 border rounded-md bg-gray-100 text-gray-600"
                  />
                </div>
                <div>
                  <label htmlFor="replySubject" className="block text-sm font-medium text-gray-700">Subject:</label>
                  <input
                    id="replySubject"
                    type="text"
                    value={replySubject}
                    onChange={(e) => setReplySubject(e.target.value)}
                    className="w-full p-2 border rounded-md focus:ring-blue-500 focus:border-blue-500"
                  />
                </div>
                <div>
                  <label htmlFor="replyBody" className="block text-sm font-medium text-gray-700">Body:</label>
                  <textarea
                      id="replyBody"
                      value={replyBody}
                      onChange={(e) => setReplyBody(e.target.value)}
                      className="w-full p-3 border rounded-md focus:ring-blue-500 focus:border-blue-500 min-h-[200px]"
                      placeholder={aiGenerating ? "Generating AI reply..." : "Type your reply here or use AI to generate one above..."}
                      disabled={aiGenerating} // Disable while generating
                  />
                </div>
                <button
                    onClick={handleSendReply}
                    className="bg-blue-600 text-white px-5 py-2 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:opacity-60 disabled:cursor-not-allowed"
                    disabled={!replyBody.trim() || !replySubject.trim() || sendStatus === "Sending..." || aiGenerating}
                >
                    {sendStatus === "Sending..." ? "Sending..." : "Send Reply"}
                </button>
                {sendStatus && (
                  <p className={`text-sm font-medium mt-2 ${sendStatus.startsWith('‚ùå Error') ? 'text-red-600' : 'text-green-600'}`}>
                    {sendStatus}
                  </p>
                )}
            </div>
      </section>
    </div>
  );
}

--- END OF /home/rick110/RickDrive/email_automation/frontend/app/emails/[id]/page.tsx ---


--- START OF /home/rick110/RickDrive/email_automation/frontend/components/AuthProviders.tsx ---

"use client"; // <--- VERY IMPORTANT: This makes it a Client Component

import { SessionProvider } from "next-auth/react";
import { ReactNode } from "react";

interface AuthProvidersProps {
  children: ReactNode;
}

export default function AuthProviders({ children }: AuthProvidersProps) {
  return <SessionProvider>{children}</SessionProvider>;
}
--- END OF /home/rick110/RickDrive/email_automation/frontend/components/AuthProviders.tsx ---


--- START OF /home/rick110/RickDrive/email_automation/frontend/components/AuthUI.tsx ---

// components/AuthUI.tsx
"use client";

import { useSession, signIn, signOut } from "next-auth/react";

export default function AuthUI() {
  const { data: session } = useSession();

  if (!session) {
    return <button onClick={() => signIn("google")}>Login with Google</button>;
  }

  return (
    <div>
      <p>Welcome, {session.user?.email}</p>
      <button onClick={() => signOut()}>Logout</button>
    </div>
  );
}

--- END OF /home/rick110/RickDrive/email_automation/frontend/components/AuthUI.tsx ---


--- START OF /home/rick110/RickDrive/email_automation/frontend/components/SendTokenToBackend.tsx ---

// File: frontend/components/SendTokenToBackend.tsx
"use client";

import { useSession } from "next-auth/react";
import { useEffect } from "react";

export default function SendTokenToBackend() {
  const { data: session, status } = useSession(); // ‚úÖ ADDED: status

  useEffect(() => {
    // ‚úÖ IMPROVED: Check for authenticated status
    if (status === "authenticated" && session?.accessToken) {
      console.log("Attempting to send token to backend...");
      fetch("http://localhost:8000/api/store-token", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          access_token: session.accessToken,
          // ‚úÖ ADDED: Sending refresh_token and user_email
          refresh_token: session.refreshToken,
          user_email: session.user?.email,
        }),
      })
        .then((res) => {
          if (!res.ok) {
            return res.text().then(text => { throw new Error(`HTTP error! status: ${res.status}, body: ${text}`); });
          }
          return res.json();
        })
        .then((data) => console.log("‚úÖ Token sent to backend:", data))
        .catch((err) => console.error("‚ùå Error sending token:", err));
    } else if (status === "unauthenticated") {
        console.log("User is unauthenticated, not sending token to backend.");
    } else if (status === "loading") {
        console.log("Session is loading, waiting to send token to backend.");
    }
  }, [session, status]); // ‚úÖ ADDED: status to dependency array

  return <p>Token has been sent to the backend (check console).</p>;
}
--- END OF /home/rick110/RickDrive/email_automation/frontend/components/SendTokenToBackend.tsx ---


--- START OF /home/rick110/RickDrive/email_automation/frontend/components/SendEmailForm.tsx ---


--- END OF /home/rick110/RickDrive/email_automation/frontend/components/SendEmailForm.tsx ---


--- START OF /home/rick110/RickDrive/email_automation/frontend/lib/utils.ts ---

import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

--- END OF /home/rick110/RickDrive/email_automation/frontend/lib/utils.ts ---


--- START OF /home/rick110/RickDrive/email_automation/frontend/types/next-auth.d.ts ---

// /home/rick110/RickDrive/email_automation/frontend/types/next-auth.d.ts or wherever you keep it

import NextAuth, { DefaultSession, DefaultUser } from "next-auth";
import { JWT } from "next-auth/jwt";

declare module "next-auth" {
  /**
   * Returned by `useSession`, `getSession` and received as a prop on the `SessionProvider` React Context
   */
  interface Session {
    accessToken?: string;
    refreshToken?: string;
    error?: "RefreshAccessTokenError";
    user?: {
      email?: string | null;
      name?: string | null;
      image?: string | null;
    } & DefaultSession["user"]; // Merge with default user properties
  }

  interface User extends DefaultUser {
    // Add custom properties to User if needed
  }
}

declare module "next-auth/jwt" {
  /**
   * Returned by the `jwt` callback and `getToken`, when using JWT sessions
   */
  interface JWT {
    accessToken?: string;
    refreshToken?: string;
    accessTokenExpires?: number;
    user?: DefaultUser;
    error?: "RefreshAccessTokenError";
  }
}
--- END OF /home/rick110/RickDrive/email_automation/frontend/types/next-auth.d.ts ---


--- START OF /home/rick110/RickDrive/email_automation/backend/main.py ---

# /home/rick110/RickDrive/email_automation/backend/main.py

from fastapi import FastAPI, HTTPException, Query
from pydantic import BaseModel, EmailStr
from fastapi.middleware.cors import CORSMiddleware
import groq # Ensure this is installed: pip install groq
import re # Needed for post-processing AI generated text

# Import your database and Gmail reader functions
from database import get_emails_from_db, insert_email, update_email_status, create_email_table
from gmail_reader import get_gmail_messages, send_email

# --- Groq Client Initialization ---
# WARNING: Hardcoding API keys is a security risk. Use environment variables in production.
GROQ_API_KEY = "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" 

try:
    if not GROQ_API_KEY or GROQ_API_KEY == "YOUR_GROQ_API_KEY_HERE":
        print("üî¥ FATAL: Groq API key is not set in the code or is a placeholder. Please replace 'YOUR_GROQ_API_KEY_HERE'.")
        groq_client = None
    else:
        groq_client = groq.Client(api_key=GROQ_API_KEY)
        print("‚úÖ Groq client initialized successfully.")
except Exception as e:
    print(f"üî¥ FATAL: Failed to initialize Groq client. Error: {e}")
    groq_client = None

app = FastAPI()

# --- CORS Middleware ---
origins = [
    "http://localhost:3000", # Your Next.js frontend
    # Add any other origins your frontend might be hosted on
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.on_event("startup")
async def startup_event():
    """
    Ensure the database table exists on application startup.
    """
    create_email_table()
    print("‚úÖ Database table ensured to exist.")


# --- Pydantic Models ---
class TokenPayload(BaseModel):
    access_token: str
    refresh_token: str | None = None
    user_email: EmailStr # Use EmailStr for email validation

class SendEmailPayload(BaseModel):
    access_token: str
    to: EmailStr
    subject: str
    body: str
    original_message_id: str | None = None

class MarkEmailReadPayload(BaseModel):
    email_id: str
    access_token: str # Retained for potential future use or consistency

class UpdateEmailStatusPayload(BaseModel):
    email_id: str
    is_read: bool | None = None
    is_replied: bool | None = None
    reply_status: str | None = None

# --- NEW Model for Groq Body Generation Request ---
class GenerateEmailBodyRequest(BaseModel):
    access_token: str # Still pass token for frontend consistency and potential backend auth check
    user_email: EmailStr
    context: str # The user's prompt or context for generating the email
    sender: EmailStr # Original sender's email
    subject: str # Original email subject


# --- API Endpoints ---
@app.get("/")
async def read_root():
    """
    Basic health check endpoint.
    """
    return {"message": "FastAPI Backend is running!"}

@app.post("/api/store-token")
async def store_token(payload: TokenPayload):
    """
    Receives and acknowledges user tokens.
    In a real app, you would securely store these tokens associated with a user.
    """
    print(f"Received token for {payload.user_email}. (Token not persistently stored in this example backend)")
    return {"message": "Token received successfully on backend!", "email": payload.user_email}

@app.post("/api/read-emails")
async def read_emails_and_process(
    payload: TokenPayload,
    email_id: str | None = Query(None, description="Optional email ID to fetch a specific email"),
    fetch_new: bool = Query(True, description="Whether to fetch new emails from Gmail or rely on database only"),
    limit: int = Query(10, description="Maximum number of emails to return")
):
    """
    Fetches emails from Gmail (if requested) and/or the local database.
    Does NOT perform sentiment analysis or generate suggested replies via Groq.
    """
    print(f"Processing /api/read-emails request. Email ID: {email_id}, Fetch New: {fetch_new}, Limit: {limit}")

    if not payload.access_token:
        raise HTTPException(status_code=400, detail="Access token is missing.")
    
    retrieved_emails_from_gmail = []
    
    # Fetch from Gmail if 'fetch_new' is true, or if a specific email_id is requested (to ensure latest data)
    if fetch_new or email_id:
        try:
            # Query for unread messages when listing. When fetching by ID, no search query is needed.
            gmail_query = "is:unread" if not email_id else None 
            
            emails_from_gmail = get_gmail_messages(
                payload.access_token,
                max_results=20, # Keep fetching max 20 unread for initial sync
                email_id=email_id,
                query=gmail_query
            )
            retrieved_emails_from_gmail = emails_from_gmail

            # Store/update fetched emails in the database
            for email_data in emails_from_gmail:
                # Initialize default values. Sentiment and suggested_reply_body are no longer generated.
                email_data['sentiment'] = 'N/A' # Will always be N/A now
                email_data['reply_status'] = email_data.get('reply_status', 'Not Replied')
                email_data['is_read'] = 0 # Mark as unread initially (unless specifically fetched email is already read)
                email_data['is_replied'] = 0 # Mark as unreplied initially
                email_data['suggested_reply_body'] = None # No longer generated
                insert_email(email_data) # Insert or update

        except Exception as e:
            print(f"‚ùå Error fetching emails from Gmail: {e}")
            # Do not raise HTTPException here, allow proceeding with DB emails
            # This allows the app to function even if Gmail API calls fail temporarily
    
    # --- Logic for returning emails ---
    if email_id:
        # If a specific email_id is requested, fetch and return only that one from DB
        db_emails = get_emails_from_db(email_id=email_id)
        if not db_emails:
            # If specific email not found in DB even after trying Gmail fetch, raise 404
            raise HTTPException(status_code=404, detail=f"Email with ID '{email_id}' not found in database.")
        
        email_to_return = db_emails[0]
        # Sentiment and suggested_reply_body are not processed here
        return {"email": {
            "id": email_to_return["id"],
            "from": email_to_return["from_address"],
            "subject": email_to_return["subject"],
            "snippet": email_to_return["snippet"],
            "sentiment": email_to_return.get("sentiment", "N/A"), # Still returned, but will be 'N/A'
            "reply_status": email_to_return["reply_status"],
            "suggested_reply_body": email_to_return.get("suggested_reply_body"), # Will be None
            "full_body": email_to_return["full_body"]
        }}
        
    else: 
        # If no specific email_id, return a list of unread/unreplied emails from DB based on filters
        final_emails_to_return = get_emails_from_db(limit=limit, is_read=False, is_replied=False)
        
        # Map DB column names to frontend expected names
        formatted_emails = [
            {
                "id": email["id"],
                "from": email["from_address"],
                "subject": email["subject"],
                "snippet": email["snippet"],
                "sentiment": email.get("sentiment", "N/A"), # Still returned, but will be 'N/A'
                "reply_status": email["reply_status"],
                "suggested_reply_body": email.get("suggested_reply_body"), # Will be None
                "full_body": email["full_body"]
            } for email in final_emails_to_return
        ]

        return {"emails": formatted_emails}


@app.post("/api/send-manual-email")
async def send_manual_email_route(payload: SendEmailPayload):
    """
    Sends an email using the Gmail API via `gmail_reader.py`.
    Marks the original email as replied in the database if an `original_message_id` is provided.
    """
    print(f"‚û°Ô∏è Manually sending email to {payload.to}")
    if not all([payload.access_token, payload.to, payload.subject, payload.body]):
        raise HTTPException(status_code=400, detail="Missing required fields for sending an email.")

    try:
        result = send_email(payload.access_token, payload.to, payload.subject, payload.body)
        print("‚úÖ Manual email sent. Message ID:", result.get("id"))

        if payload.original_message_id:
            # Mark the original email as replied if a message ID was provided
            update_email_status(payload.original_message_id, is_replied=True, reply_status="User Replied")
            print(f"Marked email {payload.original_message_id} as replied in DB.")

        return {"success": True, "messageId": result.get("id")}
    except Exception as e:
        print(f"‚ùå Error in /api/send-manual-email endpoint: {e}")
        error_message = str(e)
        if "invalid_grant" in error_message.lower() or "auth" in error_message.lower() or "token" in error_message.lower():
            raise HTTPException(status_code=401, detail="Authentication error. The token may have expired. Please sign in again.")
        raise HTTPException(status_code=500, detail=f"Failed to send email: {error_message}")


@app.post("/api/mark-email-read")
async def mark_email_read(payload: MarkEmailReadPayload):
    """
    Marks an email as read in the local database.
    """
    print(f"Attempting to mark email {payload.email_id} as read...")
    try:
        success = update_email_status(payload.email_id, is_read=True)
        if success:
            return {"success": True, "message": f"Email {payload.email_id} marked as read."}
        else:
            raise HTTPException(status_code=404, detail="Email not found or no update needed.")
    except Exception as e:
        print(f"‚ùå Error marking email as read: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to mark email as read: {str(e)}")

@app.post("/api/update-email-status")
async def api_update_email_status(payload: UpdateEmailStatusPayload):
    """
    Updates the read, replied, or reply status of an email in the local database.
    """
    print(f"Attempting to update status for email {payload.email_id} with is_read={payload.is_read}, is_replied={payload.is_replied}, reply_status={payload.reply_status}...")
    try:
        success = update_email_status(
            payload.email_id,
            is_read=payload.is_read,
            is_replied=payload.is_replied,
            reply_status=payload.reply_status
        )
        if success:
            return {"success": True, "message": f"Email {payload.email_id} status updated."}
        else:
            raise HTTPException(status_code=404, detail="Email not found or no update needed.")
    except Exception as e:
        print(f"‚ùå Error updating email status: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to update email status: {str(e)}")


# --- NEW Endpoint for Groq AI Body Generation ---
@app.post("/api/generate-email-body")
async def generate_email_body(request: GenerateEmailBodyRequest):
    """
    Generates an email body using Groq AI based on the provided context, sender, and subject.
    """
    if not groq_client:
        raise HTTPException(status_code=500, detail="Groq client is not configured on the server. Check the API key initialization.")
    
    # You might want to add more robust authentication/authorization checks here
    # beyond just having an access token. For this example, we assume presence
    # of access_token implies frontend authentication is handled.

    try:
        # Construct the prompt for Groq
        prompt_messages = [
            {
                "role": "system",
                "content": (
                    "You are an AI assistant designed to help compose professional email replies or new emails. "
                    "Focus on generating a concise, clear, and contextually appropriate email body. "
                    "Do not include subject lines, 'To:', 'From:', salutations like 'Dear/Hi [Name]', or closings like 'Sincerely/Best regards, [Your Name]'. "
                    "Just provide the main body content of the email."
                )
            },
            {
                "role": "user",
                "content": (
                    f"Compose an email. The original sender was: {request.sender}. "
                    f"The original email subject was: {request.subject}. "
                    f"The core context/instruction for this new email/reply is: {request.context}"
                )
            }
        ]

        # Call Groq API for chat completion
        chat_completion = groq_client.chat.completions.create(
            messages=prompt_messages,
            model="llama3-8b-8192", # You can choose other models available on Groq (e.g., "mixtral-8x7b-32768")
            temperature=0.7, # Adjust creativity (0.0 for deterministic, 1.0 for more creative)
            max_tokens=500, # Limit the length of the generated body to avoid overly long responses
        )

        generated_body = chat_completion.choices[0].message.content.strip()

        # Post-processing: Remove common salutations/closings if the model occasionally adds them
        generated_body = re.sub(r"^(Dear|Hi|Hello)\s+[^,\n]+[,!\.]?\s*\n*", "", generated_body, flags=re.IGNORECASE)
        generated_body = re.sub(r"\n*(Sincerely|Best regards|Thanks|Regards|Cheers)[,!\.]?\s*\[?Your Name\]?\s*$", "", generated_body, flags=re.IGNORECASE)
        generated_body = generated_body.strip()


        return {"success": True, "generated_body": generated_body}

    except Exception as e:
        print(f"‚ùå Error generating email body: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to generate email body: {str(e)}")


--- END OF /home/rick110/RickDrive/email_automation/backend/main.py ---


--- START OF /home/rick110/RickDrive/email_automation/backend/gmail_reader.py ---

import requests
import time
import base64
from email.mime.text import MIMEText
from googleapiclient.discovery import build
from google.oauth2.credentials import Credentials

def get_gmail_messages(access_token: str, max_results: int = 5, email_id: str | None = None, query: str | None = None):
    headers = {
        "Authorization": f"Bearer {access_token}"
    }
    start_time = time.time()
    print(f"[{time.time() - start_time:.2f}s] Starting Gmail API call...")

    messages_to_process = []

    if email_id:
        print(f"[{time.time() - start_time:.2f}s] Fetching specific message: {email_id}...")
        # Request full format to get all body parts and headers
        msg_url = f"https://gmail.googleapis.com/gmail/v1/users/me/messages/{email_id}?format=full"
        msg_response = requests.get(msg_url, headers=headers)
        if msg_response.status_code == 200:
            messages_to_process.append(msg_response.json())
        else:
            print(f"Error fetching specific message {email_id}:", msg_response.text)
            return []
    else:
        list_url = f"https://gmail.googleapis.com/gmail/v1/users/me/messages?maxResults={max_results}"
        if query:
            list_url += f"&q={query}"
        
        # Always add INBOX label unless a specific label or query is already present that overrides it
        if not query or ("in:inbox" not in query.lower() and "labelids" not in list_url.lower()):
            list_url += "&labelIds=INBOX"

        list_response = requests.get(list_url, headers=headers)
        print(f"[{time.time() - start_time:.2f}s] List messages response: {list_response.status_code}")

        if list_response.status_code != 200:
            print("Error listing messages:", list_response.text)
            return []

        messages_to_process = list_response.json().get("messages", [])
        if not messages_to_process:
            print(f"[{time.time() - start_time:.2f}s] No messages found with current criteria.")
            return []
        print(f"[{time.time() - start_time:.2f}s] Found {len(messages_to_process)} messages. Fetching details...")

    detailed_messages = []
    for i, msg in enumerate(messages_to_process):
        msg_id = msg["id"]
        
        # If we already fetched the full data for a specific email_id, use that
        # Otherwise, fetch the full details for each message in the list
        data = msg
        if not email_id or msg_id != email_id: # Only refetch if not already the specific email, or if it's a list
            msg_url = f"https://gmail.googleapis.com/gmail/v1/users/me/messages/{msg_id}?format=full"
            msg_response = requests.get(msg_url, headers=headers)
            print(f"[{time.time() - start_time:.2f}s] Fetched message {i+1}/{len(messages_to_process)} (ID: {msg_id[:5]}...): {msg_response.status_code}")

            if msg_response.status_code != 200:
                print(f"Error fetching message {msg_id}:", msg_response.text)
                continue
            data = msg_response.json()

        payload_headers = data.get("payload", {}).get("headers", [])
        headers_dict = {h["name"].lower(): h["value"] for h in payload_headers}

        full_body = ""
        # Prioritize HTML body, then plain text
        html_body = ""
        plain_body = ""

        def decode_body_part(part_data):
            try:
                return base64.urlsafe_b64decode(part_data).decode("utf-8")
            except Exception as e:
                print(f"Error decoding body part: {e}")
                return ""

        # Recursive function to find parts
        def get_parts(payload):
            if "body" in payload and "data" in payload["body"]:
                if payload["mimeType"] == "text/plain":
                    nonlocal plain_body
                    plain_body = decode_body_part(payload["body"]["data"])
                elif payload["mimeType"] == "text/html":
                    nonlocal html_body
                    html_body = decode_body_part(payload["body"]["data"])
            if "parts" in payload:
                for part in payload["parts"]:
                    get_parts(part)

        get_parts(data.get("payload", {}))

        full_body = html_body if html_body else plain_body # Prefer HTML if available

        detailed_messages.append({
            "id": msg_id,
            "threadId": data.get("threadId"),
            "historyId": data.get("historyId"),
            "from": headers_dict.get("from", ""), # Ensures it defaults to empty string if header is missing
            "subject": headers_dict.get("subject", ""),
            "snippet": data.get("snippet", ""),
            "internalDate": data.get("internalDate"),
            "full_body": full_body,
            "is_read": 0, # Default to unread when fetched
            "is_replied": 0 # Default to unreplied when fetched
        })

    print(f"[{time.time() - start_time:.2f}s] All messages processed. Total time.")
    return detailed_messages


def send_email(access_token: str, to: str, subject: str, body: str):
    print("üì§ Sending email...")
    # Credentials object from google.oauth2.credentials
    # This assumes the access_token is valid and has the necessary scopes.
    creds = Credentials(token=access_token)
    
    # Build the Gmail service
    service = build("gmail", "v1", credentials=creds)

    # Create the email message
    message = MIMEText(body)
    message["to"] = to
    message["subject"] = subject
    
    # Encode the message into a base64urlsafe string
    raw_message = base64.urlsafe_b64encode(message.as_bytes()).decode()

    # Send the email
    response = service.users().messages().send(userId="me", body={"raw": raw_message}).execute()
    print("‚úÖ Email sent. Message ID:", response.get("id"))
    return response
--- END OF /home/rick110/RickDrive/email_automation/backend/gmail_reader.py ---


--- START OF /home/rick110/RickDrive/email_automation/backend/database.py ---

# /home/rick110/RickDrive/email_automation/backend/database.py

import sqlite3
from typing import List, Dict, Optional

DATABASE_URL = "emails.db" # This will create a file in your backend directory

def get_db_connection():
    conn = sqlite3.connect(DATABASE_URL)
    conn.row_factory = sqlite3.Row # This allows access to columns by name
    return conn

def create_email_table():
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS emails (
            id TEXT PRIMARY KEY,
            threadId TEXT,
            historyId TEXT,
            from_address TEXT NOT NULL,
            subject TEXT,
            snippet TEXT,
            internalDate INTEGER,
            sentiment TEXT DEFAULT 'N/A', -- Kept for compatibility, but no longer populated by Groq
            reply_status TEXT DEFAULT 'Not Replied',
            suggested_reply_body TEXT, -- Kept for compatibility, but no longer populated by Groq
            full_body TEXT, -- To store the full email body when fetched
            is_read INTEGER DEFAULT 0, -- 0 for unread, 1 for read
            is_replied INTEGER DEFAULT 0, -- 0 for unreplied, 1 for replied
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
    """)
    conn.commit()
    conn.close()

def insert_email(email_data: Dict):
    conn = get_db_connection()
    cursor = conn.cursor()
    # Check if email already exists
    cursor.execute("SELECT id FROM emails WHERE id = ?", (email_data['id'],))
    existing_email = cursor.fetchone()

    if existing_email:
        print(f"Email with ID {email_data['id']} already exists. Updating...")
        cursor.execute("""
            UPDATE emails
            SET from_address = ?, subject = ?, snippet = ?, sentiment = ?,
                reply_status = ?, suggested_reply_body = ?, full_body = ?,
                is_read = ?, is_replied = ?, updated_at = CURRENT_TIMESTAMP
            WHERE id = ?
        """, (
            email_data.get('from', ''),
            email_data.get('subject', ''),
            email_data.get('snippet', ''),
            email_data.get('sentiment', 'N/A'), # Will be 'N/A' now
            email_data.get('reply_status', 'Not Replied'),
            email_data.get('suggested_reply_body'), # Will be None now
            email_data.get('full_body'),
            int(email_data.get('is_read', 0)),
            int(email_data.get('is_replied', 0)),
            email_data['id']
        ))
    else:
        print(f"Inserting new email with ID {email_data['id']}...")
        cursor.execute("""
            INSERT INTO emails (id, threadId, historyId, from_address, subject, snippet, internalDate,
                                 sentiment, reply_status, suggested_reply_body, full_body, is_read, is_replied)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            email_data['id'],
            email_data.get('threadId'),
            email_data.get('historyId'),
            email_data.get('from', ''),
            email_data.get('subject', ''),
            email_data.get('snippet', ''),
            email_data.get('internalDate'),
            email_data.get('sentiment', 'N/A'), # Will be 'N/A' now
            email_data.get('reply_status', 'Not Replied'),
            email_data.get('suggested_reply_body'), # Will be None now
            email_data.get('full_body'),
            int(email_data.get('is_read', 0)),
            int(email_data.get('is_replied', 0))
        ))
    conn.commit()
    conn.close()

def get_emails_from_db(
    limit: int = 10,
    offset: int = 0,
    sentiment: Optional[str] = None, # Can still be used for filtering existing data
    reply_status: Optional[str] = None,
    is_read: Optional[bool] = None,
    is_replied: Optional[bool] = None,
    email_id: Optional[str] = None
) -> List[Dict]:
    conn = get_db_connection()
    cursor = conn.cursor()

    query = "SELECT * FROM emails WHERE 1=1"
    params = []

    if email_id:
        query += " AND id = ?"
        params.append(email_id)

    if sentiment:
        query += " AND sentiment = ?"
        params.append(sentiment.upper())
    if reply_status:
        query += " AND reply_status = ?"
        params.append(reply_status)
    if is_read is not None:
        query += " AND is_read = ?"
        params.append(1 if is_read else 0)
    if is_replied is not None:
        query += " AND is_replied = ?"
        params.append(1 if is_replied else 0)

    query += " ORDER BY internalDate DESC LIMIT ? OFFSET ?"
    params.extend([limit, offset])

    cursor.execute(query, params)
    emails = cursor.fetchall()
    conn.close()
    return [dict(email) for email in emails]

def update_email_status(email_id: str, is_read: Optional[bool] = None, is_replied: Optional[bool] = None, reply_status: Optional[str] = None):
    conn = get_db_connection()
    cursor = conn.cursor()
    update_fields = []
    params = []

    if is_read is not None:
        update_fields.append("is_read = ?")
        params.append(1 if is_read else 0)
    if is_replied is not None:
        update_fields.append("is_replied = ?")
        params.append(1 if is_replied else 0)
    if reply_status is not None:
        update_fields.append("reply_status = ?")
        params.append(reply_status)

    if not update_fields:
        conn.close()
        return False # Nothing to update

    query = f"UPDATE emails SET {', '.join(update_fields)}, updated_at = CURRENT_TIMESTAMP WHERE id = ?"
    params.append(email_id)

    cursor.execute(query, params)
    conn.commit()
    rows_affected = cursor.rowcount
    conn.close()
    return rows_affected > 0

# Initialize the database table when this module is imported
create_email_table()
--- END OF /home/rick110/RickDrive/email_automation/backend/database.py ---

